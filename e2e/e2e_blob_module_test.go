package e2e

import (
	"bytes"
	"context"
	nodeblob "github.com/celestiaorg/celestia-node/blob"
	"github.com/celestiaorg/celestia-node/state"
	libshare "github.com/celestiaorg/go-square/v2/share"
	"testing"
)

func (s *CelestiaTestSuite) TestE2EBlobModule() {
	t := s.T()
	if testing.Short() {
		t.Skip("skipping in short mode")
	}

	ctx := context.TODO()
	fullNodeClient := s.GetNodeRPCClient(ctx, s.fullNode)
	lightNodeClient := s.GetNodeRPCClient(ctx, s.lightNode)

	addr, err := fullNodeClient.State.AccountAddress(ctx)
	s.Require().NoError(err)

	wallet := s.CreateTestWallet(ctx, s.celestia, 100_000_000_000)

	// fund the wallet generated by the full node.
	s.FundWallet(ctx, s.celestia, wallet, addr.Bytes(), 100_000_000_00)

	v1Blob, err := libshare.NewV1Blob(
		libshare.MustNewV0Namespace(bytes.Repeat([]byte{5}, libshare.NamespaceVersionZeroIDSize)),
		[]byte("test data"),
		addr.Bytes(),
	)
	s.Require().NoError(err)

	libBlobs0, err := libshare.GenerateV0Blobs([]int{8, 4}, true)
	s.Require().NoError(err)

	libBlobs1, err := libshare.GenerateV0Blobs([]int{4}, false)
	s.Require().NoError(err)

	blobs, err := nodeblob.ToNodeBlobs(append(libBlobs0, libBlobs1...)...)
	s.Require().NoError(err)

	v1, err := nodeblob.ToNodeBlobs(v1Blob)
	s.Require().NoError(err)
	blobs = append(blobs, v1[0])

	txConfig := state.NewTxConfig(
		state.WithGas(200_000),
		state.WithGasPrice(5000),
	)

	height, err := fullNodeClient.Blob.Submit(ctx, blobs, txConfig)
	s.Require().NoError(err)

	_, err = fullNodeClient.Header.WaitForHeight(ctx, height)
	s.Require().NoError(err)
	_, err = lightNodeClient.Header.WaitForHeight(ctx, height)
	s.Require().NoError(err)

	test := []struct {
		name string
		doFn func(t *testing.T)
	}{
		{
			name: "GetV0",
			doFn: func(t *testing.T) {
				blob1, err := fullNodeClient.Blob.Get(ctx, height, blobs[0].Namespace(), blobs[0].Commitment)
				s.Require().NoError(err)
				s.Require().Equal(blobs[0].Commitment, blob1.Commitment)
				s.Require().Equal(blobs[0].Data(), blob1.Data())
				s.Require().Nil(blob1.Signer())
			},
		},
		{
			name: "GetAllV0",
			doFn: func(t *testing.T) {
				newBlobs, err := fullNodeClient.Blob.GetAll(ctx, height, []libshare.Namespace{blobs[0].Namespace()})
				s.Require().NoError(err)
				s.Require().Len(newBlobs, len(libBlobs0))
				s.Require().Equal(blobs[0].Commitment, newBlobs[0].Commitment)
				s.Require().Equal(blobs[1].Commitment, newBlobs[1].Commitment)
				s.Require().Nil(newBlobs[0].Signer())
				s.Require().Nil(newBlobs[1].Signer())
			},
		},
		{
			name: "Get BlobV1",
			doFn: func(t *testing.T) {
				blobV1, err := fullNodeClient.Blob.Get(ctx, height, v1[0].Namespace(), v1[0].Commitment)
				s.Require().NoError(err)
				s.Require().Equal(libshare.ShareVersionOne, blobV1.ShareVersion())
				s.Require().Equal(v1[0].Commitment, blobV1.Commitment)
				s.Require().NotNil(blobV1.Signer())
				s.Require().Equal(blobV1.Signer(), v1[0].Signer())
			},
		},
		{
			name: "Included",
			doFn: func(t *testing.T) {
				proof, err := fullNodeClient.Blob.GetProof(ctx, height, blobs[0].Namespace(), blobs[0].Commitment)
				s.Require().NoError(err)

				included, err := lightNodeClient.Blob.Included(
					ctx,
					height,
					blobs[0].Namespace(),
					proof,
					blobs[0].Commitment,
				)
				s.Require().NoError(err)
				s.Require().True(included)
			},
		},
		{
			name: "Not Found",
			doFn: func(t *testing.T) {
				libBlob, err := libshare.GenerateV0Blobs([]int{4}, false)
				s.Require().NoError(err)
				newBlob, err := nodeblob.ToNodeBlobs(libBlob[0])
				s.Require().NoError(err)

				b, err := fullNodeClient.Blob.Get(ctx, height, newBlob[0].Namespace(), newBlob[0].Commitment)
				s.Require().Nil(b)
				s.Require().Error(err)
				s.Require().ErrorContains(err, nodeblob.ErrBlobNotFound.Error())

				blobs, err := fullNodeClient.Blob.GetAll(ctx, height, []libshare.Namespace{newBlob[0].Namespace()})
				s.Require().NoError(err)
				s.Require().Empty(blobs)
			},
		},
		{
			name: "Submit equal blobs",
			doFn: func(t *testing.T) {
				libBlob, err := libshare.GenerateV0Blobs([]int{8, 4}, true)
				s.Require().NoError(err)
				b, err := nodeblob.ToNodeBlobs(libBlob[0])
				s.Require().NoError(err)

				height, err := fullNodeClient.Blob.Submit(ctx, []*nodeblob.Blob{b[0], b[0]}, txConfig)
				s.Require().NoError(err)

				_, err = fullNodeClient.Header.WaitForHeight(ctx, height)
				s.Require().NoError(err)

				b0, err := fullNodeClient.Blob.Get(ctx, height, b[0].Namespace(), b[0].Commitment)
				s.Require().NoError(err)
				s.Require().Equal(b[0].Commitment, b0.Commitment)

				proof, err := fullNodeClient.Blob.GetProof(ctx, height, b[0].Namespace(), b[0].Commitment)
				s.Require().NoError(err)

				included, err := fullNodeClient.Blob.Included(ctx, height, b[0].Namespace(), proof, b[0].Commitment)
				s.Require().NoError(err)
				s.Require().True(included)
			},
		},
		{
			// This test allows to check that the blob won't be
			// deduplicated if it will be sent multiple times in
			// different pfbs.
			name: "Submit the same blob in different pfb",
			doFn: func(t *testing.T) {
				h, err := fullNodeClient.Blob.Submit(ctx, []*nodeblob.Blob{blobs[0]}, txConfig)
				s.Require().NoError(err)

				_, err = fullNodeClient.Header.WaitForHeight(ctx, h)
				s.Require().NoError(err)

				b0, err := fullNodeClient.Blob.Get(ctx, h, blobs[0].Namespace(), blobs[0].Commitment)
				s.Require().NoError(err)
				s.Require().Equal(blobs[0].Commitment, b0.Commitment)

				proof, err := fullNodeClient.Blob.GetProof(ctx, h, blobs[0].Namespace(), blobs[0].Commitment)
				s.Require().NoError(err)

				included, err := fullNodeClient.Blob.Included(ctx, h, blobs[0].Namespace(), proof, blobs[0].Commitment)
				s.Require().NoError(err)
				s.Require().True(included)
			},
		},
	}

	for _, tt := range test {
		tt := tt
		t.Run(tt.name, func(t *testing.T) {
			tt.doFn(t)
		})
	}
}
