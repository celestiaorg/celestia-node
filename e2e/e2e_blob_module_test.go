package e2e

import (
	"bytes"
	"context"
	"fmt"
	nodeblob "github.com/celestiaorg/celestia-node/blob"
	"github.com/celestiaorg/celestia-node/state"
	sdk "github.com/cosmos/cosmos-sdk/types"
	banktypes "github.com/cosmos/cosmos-sdk/x/bank/types"
	"google.golang.org/grpc"
	"log"
	"testing"
	"time"

	libshare "github.com/celestiaorg/go-square/v2/share"
	"github.com/celestiaorg/tastora/framework/testutil/sdkacc"
	"github.com/celestiaorg/tastora/framework/testutil/wait"
)

func (s *CelestiaTestSuite) TestE2EBlobModule() {
	t := s.T()
	if testing.Short() {
		t.Skip("skipping in short mode")
	}

	ctx := context.TODO()

	celestia := s.CreateAndStartCelestiaChain(ctx)

	// wait for some blocks to ensure the bridge node can sync up.
	s.Require().NoError(wait.ForBlocks(ctx, 10, celestia))

	wallet := s.CreateTestWallet(ctx, celestia, 100_000_000_000)

	bridgeNode := s.CreateAndStartBridgeNode(ctx, celestia)

	fullNode := s.CreateAndStartFullNode(ctx, bridgeNode, celestia)

	celestiaHeight, err := celestia.Height(ctx)
	s.Require().NoError(err, "failed to get celestia height")

	ns := libshare.RandomBlobNamespace()
	signer := wallet.GetFormattedAddress()

	signerAddr, err := sdkacc.AddressFromBech32(signer, "celestia")
	s.Require().NoError(err, "failed to get signer address")

	msg, blob := randMsgPayForBlobsWithNamespaceAndSigner(signer, signerAddr, ns, 100)

	resp, err := celestia.BroadcastBlobMessage(ctx, wallet, msg, blob)
	s.Require().NoError(err, "failed to broadcast blob message")
	s.Require().NotNil(resp, "broadcast blob message response is nil")
	s.Require().Equal(uint32(0), resp.Code, "expected successful tx broadcast, got error: %s", resp.RawLog)

	err = wait.ForDANodeToReachHeight(ctx, bridgeNode, uint64(celestiaHeight), time.Second*30)
	s.Require().NoError(err, "failed to wait for bridge node to reach height")

	err = wait.ForDANodeToReachHeight(ctx, fullNode, uint64(celestiaHeight), time.Second*30)
	s.Require().NoError(err, "failed to wait for full node to reach height")

	lightNode := s.CreateAndStartLightNode(ctx, fullNode, celestia)

	s.Require().NoError(wait.ForBlocks(ctx, 10, celestia), "failed to wait for blocks")

	celestiaHeight, err = celestia.Height(ctx)
	s.Require().NoError(err, "failed to get celestia height")

	err = wait.ForDANodeToReachHeight(ctx, lightNode, uint64(celestiaHeight), time.Second*30)
	s.Require().NoError(err, "failed to wait for light node to reach height")

	client := s.getNodeRPCClient(ctx, fullNode)

	addr, err := client.State.AccountAddress(ctx)
	s.Require().NoError(err)

	// fund the wallet generated by the full node.
	s.FundWallet(ctx, celestia, wallet, addr.Bytes(), 100_000_000_00)

	grpcAddr := celestia.GetGRPCAddress()
	bal, err := QueryBalance(ctx, grpcAddr, addr.String())
	s.Require().NoError(err)
	s.Require().Greater(bal.Amount.Int64(), int64(0), "balance is not greater than 0")

	v1Blob, err := libshare.NewV1Blob(
		libshare.MustNewV0Namespace(bytes.Repeat([]byte{5}, libshare.NamespaceVersionZeroIDSize)),
		[]byte("test data"),
		addr.Bytes(),
	)
	s.Require().NoError(err)

	libBlobs0, err := libshare.GenerateV0Blobs([]int{8, 4}, true)
	s.Require().NoError(err)

	libBlobs1, err := libshare.GenerateV0Blobs([]int{4}, false)
	s.Require().NoError(err)

	blobs, err := nodeblob.ToNodeBlobs(append(libBlobs0, libBlobs1...)...)
	s.Require().NoError(err)

	v1, err := nodeblob.ToNodeBlobs(v1Blob)
	s.Require().NoError(err)
	blobs = append(blobs, v1[0])

	_, err = client.Blob.Submit(ctx, blobs, state.NewTxConfig(
		state.WithGas(200_000),
		state.WithGasPrice(5000),
	))
	s.Require().NoError(err)
}

// QueryBalance fetches the balance of a given address and denom from a Cosmos SDK chain via gRPC.
func QueryBalance(ctx context.Context, grpcAddr string, addr string) (sdk.Coin, error) {
	grpcConn, err := grpc.Dial(grpcAddr, grpc.WithInsecure())
	if err != nil {
		log.Fatalf("failed to connect to gRPC: %v", err)
	}
	bankClient := banktypes.NewQueryClient(grpcConn)

	req := &banktypes.QueryBalanceRequest{
		Address: addr,
		Denom:   "utia",
	}

	res, err := bankClient.Balance(ctx, req)
	if err != nil {
		return sdk.Coin{}, fmt.Errorf("failed to query balance: %w", err)
	}

	return *res.Balance, nil
}
